package basic1;
// # 상속
// 상속을 이용하면 부모 클래스의 수정으로 무든 자식 클래스들도 수저오디는 효과를
// 가져오기 때문에 유지 보수 시간을 최소화할 수 있다.
// 1. 여러개의 부모 클래스를 상속할 수 없다. extends 뒤에는 단 하나의 부모 클래스만 와야함
// 2. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다.
//    그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와
//	  메소드도 상속 대상에서 제외된다.

// # 부모 생성자 호출
// 자식 객체 생성시, 부모 객체가 먼저 생성되고 그 다음에 자식 객체가 생성된다.
// 부모 생성자는 자식 생성자의 맨 첫줄에서 호출된다.
// super();
// super()는 부모의 기본 생성자를 호출한다.

// # 부모 메소드 호출
// 자식 클래스에서 부모 클래스의 메소드를 재정의하게 되면, 부모 클래스의 메소드는 숨겨지고 재정의된 자식 메소드만 사용된다
// 그러나 자식 클래스 내부에서 재정의된 부모 클래스의 메소드를 호출해야 하는 상황이 발생하면
// super.부모메소드();


// # final 클래스와 final 메소드
// final 키워드는 클래스, 필드, 메소드를 선언할 때 사용할 수 있는데, 해당 선언이 최종 상태이고 결코 수정될 수 없음을 뜻한다.
// 클래스와 메소드를 선언할 때 final 키워드가 지정되면 상속과 관련이 있다.
// 1. 상속할 수 없는 final 클래스
// => final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다
// ex) String 클래스
//     public final class String{}
// 2. 재정의할 수 없는 final 메소드
// => 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의할 수 없다.
public class src8 {

	public static void main(String[] args) {

	}

}
